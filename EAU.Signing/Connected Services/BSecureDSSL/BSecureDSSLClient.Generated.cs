//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace EAU.Signing.BSecureDSSL
{
    using System = global::System;
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial interface IBSecureDsslClient
    {
        /// <summary>Get data to sign of the specified document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="content">Content for second and more detached signatures.</param>
        /// <param name="data">Data over which digest should be calculated.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithm are: SHA256, SHA384, SHA512</param>
        /// <param name="imageHeight">Set image height for visual signature of PAdES signed document.</param>
        /// <param name="imageWidth">Set image width for visual signature of PAdES signed document.</param>
        /// <param name="imageXAxis">Set image x axis for visual signature of PAdES signed document.</param>
        /// <param name="imageYAxis">Set image y axis for visual signature of PAdES signed document.</param>
        /// <param name="padesVisualSignature">Set visual signature on last page of PAdES signed document. Supported values are TRUE, FALSE. Default value FALSE.</param>
        /// <param name="pageNumber">Set page number for visual signature of PAdES signed document.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: CAdES_BASELINE_B, CAdES_BASELINE_T, CAdES_BASELINE_LT, CAdES_BASELINE_LTA, PAdES_BASELINE_B, PAdES_BASELINE_T, PAdES_BASELINE_LT, PAdES_BASELINE_LTA, XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="signaturePackaging">Signature packaging for calculating data to be signed. Supported packagings are: ENVELOPED, ENVELOPING, DETACHED</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Data to sign retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DigestResponseDto> GetDigestUsingPOSTAsync(string accept_language, FileParameter certificate, FileParameter content, FileParameter data, string digestAlgorithm, int? imageHeight, int? imageWidth, double? imageXAxis, double? imageYAxis, bool? padesVisualSignature, int? pageNumber, string signatureLevel, string signaturePackaging, string xpathLocation, string xpathNamespaces, string xpathPrefixes);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get data to sign of the specified document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="content">Content for second and more detached signatures.</param>
        /// <param name="data">Data over which digest should be calculated.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithm are: SHA256, SHA384, SHA512</param>
        /// <param name="imageHeight">Set image height for visual signature of PAdES signed document.</param>
        /// <param name="imageWidth">Set image width for visual signature of PAdES signed document.</param>
        /// <param name="imageXAxis">Set image x axis for visual signature of PAdES signed document.</param>
        /// <param name="imageYAxis">Set image y axis for visual signature of PAdES signed document.</param>
        /// <param name="padesVisualSignature">Set visual signature on last page of PAdES signed document. Supported values are TRUE, FALSE. Default value FALSE.</param>
        /// <param name="pageNumber">Set page number for visual signature of PAdES signed document.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: CAdES_BASELINE_B, CAdES_BASELINE_T, CAdES_BASELINE_LT, CAdES_BASELINE_LTA, PAdES_BASELINE_B, PAdES_BASELINE_T, PAdES_BASELINE_LT, PAdES_BASELINE_LTA, XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="signaturePackaging">Signature packaging for calculating data to be signed. Supported packagings are: ENVELOPED, ENVELOPING, DETACHED</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Data to sign retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DigestResponseDto> GetDigestUsingPOSTAsync(string accept_language, FileParameter certificate, FileParameter content, FileParameter data, string digestAlgorithm, int? imageHeight, int? imageWidth, double? imageXAxis, double? imageYAxis, bool? padesVisualSignature, int? pageNumber, string signatureLevel, string signaturePackaging, string xpathLocation, string xpathNamespaces, string xpathPrefixes, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get data to sign of the specified external digest(s) and file name(s)</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512</param>
        /// <param name="externalDigests">Signature external digests for calculating data to be signed.</param>
        /// <param name="fileNames">File names over which external digest is calculated.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Data to sign retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DigestResponseDto> GetDigestExternalUsingPOSTAsync(string accept_language, FileParameter certificate, string digestAlgorithm, System.Collections.Generic.IEnumerable<string> externalDigests, System.Collections.Generic.IEnumerable<string> fileNames, string signatureLevel, string xpathLocation, string xpathNamespaces, string xpathPrefixes);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get data to sign of the specified external digest(s) and file name(s)</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512</param>
        /// <param name="externalDigests">Signature external digests for calculating data to be signed.</param>
        /// <param name="fileNames">File names over which external digest is calculated.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Data to sign retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DigestResponseDto> GetDigestExternalUsingPOSTAsync(string accept_language, FileParameter certificate, string digestAlgorithm, System.Collections.Generic.IEnumerable<string> externalDigests, System.Collections.Generic.IEnumerable<string> fileNames, string signatureLevel, string xpathLocation, string xpathNamespaces, string xpathPrefixes, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Create signed document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="content">Content for second and more detached signatures.</param>
        /// <param name="data">Data over which digest should be calculated.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512.</param>
        /// <param name="digestTime">Time of the digest calculation (in response from digest operation).</param>
        /// <param name="imageHeight">Set image height for visual signature of PAdES signed document.</param>
        /// <param name="imageWidth">Set image width for visual signature of PAdES signed document.</param>
        /// <param name="imageXAxis">Set image x axis for visual signature of PAdES signed document.</param>
        /// <param name="imageYAxis">Set image y axis for visual signature of PAdES signed document.</param>
        /// <param name="padesVisualSignature">Set visual signature on last page of PAdES signed document. Supported values are TRUE, FALSE. Default value FALSE.</param>
        /// <param name="pageNumber">Set page number for visual signature of PAdES signed document.</param>
        /// <param name="signature">Digital signature of digest.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: CAdES_BASELINE_B, CAdES_BASELINE_T, CAdES_BASELINE_LT, CAdES_BASELINE_LTA, PAdES_BASELINE_B, PAdES_BASELINE_T, PAdES_BASELINE_LT, PAdES_BASELINE_LTA, XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="signaturePackaging">Signature packaging for calculating data to be signed. Supported packagings are: ENVELOPED, ENVELOPING, DETACHED.</param>
        /// <param name="tsDigestAlgorithm">Signature timestamp digest algorithm for calculating timestamp of data to be signed. Supported algorithms are: SHA256, SHA512.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DocumentResponseDto> CreateSignedDocumentUsingPOSTAsync(string accept_language, FileParameter certificate, FileParameter content, FileParameter data, string digestAlgorithm, long digestTime, int? imageHeight, int? imageWidth, double? imageXAxis, double? imageYAxis, bool? padesVisualSignature, int? pageNumber, FileParameter signature, string signatureLevel, string signaturePackaging, string tsDigestAlgorithm, string xpathLocation, string xpathNamespaces, string xpathPrefixes);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create signed document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="content">Content for second and more detached signatures.</param>
        /// <param name="data">Data over which digest should be calculated.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512.</param>
        /// <param name="digestTime">Time of the digest calculation (in response from digest operation).</param>
        /// <param name="imageHeight">Set image height for visual signature of PAdES signed document.</param>
        /// <param name="imageWidth">Set image width for visual signature of PAdES signed document.</param>
        /// <param name="imageXAxis">Set image x axis for visual signature of PAdES signed document.</param>
        /// <param name="imageYAxis">Set image y axis for visual signature of PAdES signed document.</param>
        /// <param name="padesVisualSignature">Set visual signature on last page of PAdES signed document. Supported values are TRUE, FALSE. Default value FALSE.</param>
        /// <param name="pageNumber">Set page number for visual signature of PAdES signed document.</param>
        /// <param name="signature">Digital signature of digest.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: CAdES_BASELINE_B, CAdES_BASELINE_T, CAdES_BASELINE_LT, CAdES_BASELINE_LTA, PAdES_BASELINE_B, PAdES_BASELINE_T, PAdES_BASELINE_LT, PAdES_BASELINE_LTA, XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="signaturePackaging">Signature packaging for calculating data to be signed. Supported packagings are: ENVELOPED, ENVELOPING, DETACHED.</param>
        /// <param name="tsDigestAlgorithm">Signature timestamp digest algorithm for calculating timestamp of data to be signed. Supported algorithms are: SHA256, SHA512.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DocumentResponseDto> CreateSignedDocumentUsingPOSTAsync(string accept_language, FileParameter certificate, FileParameter content, FileParameter data, string digestAlgorithm, long digestTime, int? imageHeight, int? imageWidth, double? imageXAxis, double? imageYAxis, bool? padesVisualSignature, int? pageNumber, FileParameter signature, string signatureLevel, string signaturePackaging, string tsDigestAlgorithm, string xpathLocation, string xpathNamespaces, string xpathPrefixes, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Extends signed document to upper level</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="content">Content file if document signature is detached.</param>
        /// <param name="signedContent">Signed content (Signature file)</param>
        /// <returns>Extended signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DocumentExtendResponseDto> ExtendSignedDocumentUsingPOSTAsync(string accept_language, FileParameter content, FileParameter signedContent);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Extends signed document to upper level</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="content">Content file if document signature is detached.</param>
        /// <param name="signedContent">Signed content (Signature file)</param>
        /// <returns>Extended signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DocumentExtendResponseDto> ExtendSignedDocumentUsingPOSTAsync(string accept_language, FileParameter content, FileParameter signedContent, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Create signed document with externally entered digests</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512.</param>
        /// <param name="digestTime">Time of the digest calculation (in response from digest operation).</param>
        /// <param name="externalDigests">Signature external digests for calculating data to be signed.</param>
        /// <param name="fileNames">File names over which external digest is calculated.</param>
        /// <param name="signature">Digital signature of digest.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="tsDigestAlgorithm">Signature timestamp digest method for calculating timestamp of data to be signed. Supported algorithms are SHA256, SHA512.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DocumentResponseDto> CreateSignedDocumentExternalDigestUsingPOSTAsync(string accept_language, FileParameter certificate, string digestAlgorithm, long digestTime, System.Collections.Generic.IEnumerable<string> externalDigests, System.Collections.Generic.IEnumerable<string> fileNames, FileParameter signature, string signatureLevel, string tsDigestAlgorithm, string xpathLocation, string xpathNamespaces, string xpathPrefixes);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create signed document with externally entered digests</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512.</param>
        /// <param name="digestTime">Time of the digest calculation (in response from digest operation).</param>
        /// <param name="externalDigests">Signature external digests for calculating data to be signed.</param>
        /// <param name="fileNames">File names over which external digest is calculated.</param>
        /// <param name="signature">Digital signature of digest.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="tsDigestAlgorithm">Signature timestamp digest method for calculating timestamp of data to be signed. Supported algorithms are SHA256, SHA512.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DocumentResponseDto> CreateSignedDocumentExternalDigestUsingPOSTAsync(string accept_language, FileParameter certificate, string digestAlgorithm, long digestTime, System.Collections.Generic.IEnumerable<string> externalDigests, System.Collections.Generic.IEnumerable<string> fileNames, FileParameter signature, string signatureLevel, string tsDigestAlgorithm, string xpathLocation, string xpathNamespaces, string xpathPrefixes, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Validate signed document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="attachValidationCertificatesToResult">Add base64 encoded certificates to result. Supported values are: TRUE, FALSE. Default value FALSE.</param>
        /// <param name="attachValidationReportsToResult">Add base64 encoded reports to result. Supported values are: TRUE, FALSE. Default value FALSE.</param>
        /// <param name="content">Content file if document signature is detached.</param>
        /// <param name="signedContent">Signed content (Signature file)</param>
        /// <param name="validationLevel">Validation level to be used for validation. If none is specified - it is determined by the document structure. Supported validation levels are: BASIC_SIGNATURES, TIMESTAMPS, LONG_TERM_DATA, ARCHIVAL_DATA.</param>
        /// <returns>Validated signed document reports produced successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ValidateDocumentResponseDto> ValidateSignedDocumentUsingPOSTAsync(string accept_language, bool? attachValidationCertificatesToResult, bool? attachValidationReportsToResult, FileParameter content, FileParameter signedContent, string validationLevel);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Validate signed document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="attachValidationCertificatesToResult">Add base64 encoded certificates to result. Supported values are: TRUE, FALSE. Default value FALSE.</param>
        /// <param name="attachValidationReportsToResult">Add base64 encoded reports to result. Supported values are: TRUE, FALSE. Default value FALSE.</param>
        /// <param name="content">Content file if document signature is detached.</param>
        /// <param name="signedContent">Signed content (Signature file)</param>
        /// <param name="validationLevel">Validation level to be used for validation. If none is specified - it is determined by the document structure. Supported validation levels are: BASIC_SIGNATURES, TIMESTAMPS, LONG_TERM_DATA, ARCHIVAL_DATA.</param>
        /// <returns>Validated signed document reports produced successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ValidateDocumentResponseDto> ValidateSignedDocumentUsingPOSTAsync(string accept_language, bool? attachValidationCertificatesToResult, bool? attachValidationReportsToResult, FileParameter content, FileParameter signedContent, string validationLevel, System.Threading.CancellationToken cancellationToken);
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0))")]
    internal partial class BSecureDsslClient : IBSecureDsslClient
    {
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public BSecureDsslClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(() => 
            {
                var settings = new Newtonsoft.Json.JsonSerializerSettings();
                UpdateJsonSerializerSettings(settings);
                return settings;
            });
        }
    
        public Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>Get data to sign of the specified document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="content">Content for second and more detached signatures.</param>
        /// <param name="data">Data over which digest should be calculated.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithm are: SHA256, SHA384, SHA512</param>
        /// <param name="imageHeight">Set image height for visual signature of PAdES signed document.</param>
        /// <param name="imageWidth">Set image width for visual signature of PAdES signed document.</param>
        /// <param name="imageXAxis">Set image x axis for visual signature of PAdES signed document.</param>
        /// <param name="imageYAxis">Set image y axis for visual signature of PAdES signed document.</param>
        /// <param name="padesVisualSignature">Set visual signature on last page of PAdES signed document. Supported values are TRUE, FALSE. Default value FALSE.</param>
        /// <param name="pageNumber">Set page number for visual signature of PAdES signed document.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: CAdES_BASELINE_B, CAdES_BASELINE_T, CAdES_BASELINE_LT, CAdES_BASELINE_LTA, PAdES_BASELINE_B, PAdES_BASELINE_T, PAdES_BASELINE_LT, PAdES_BASELINE_LTA, XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="signaturePackaging">Signature packaging for calculating data to be signed. Supported packagings are: ENVELOPED, ENVELOPING, DETACHED</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Data to sign retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DigestResponseDto> GetDigestUsingPOSTAsync(string accept_language, FileParameter certificate, FileParameter content, FileParameter data, string digestAlgorithm, int? imageHeight, int? imageWidth, double? imageXAxis, double? imageYAxis, bool? padesVisualSignature, int? pageNumber, string signatureLevel, string signaturePackaging, string xpathLocation, string xpathNamespaces, string xpathPrefixes)
        {
            return GetDigestUsingPOSTAsync(accept_language, certificate, content, data, digestAlgorithm, imageHeight, imageWidth, imageXAxis, imageYAxis, padesVisualSignature, pageNumber, signatureLevel, signaturePackaging, xpathLocation, xpathNamespaces, xpathPrefixes, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get data to sign of the specified document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="content">Content for second and more detached signatures.</param>
        /// <param name="data">Data over which digest should be calculated.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithm are: SHA256, SHA384, SHA512</param>
        /// <param name="imageHeight">Set image height for visual signature of PAdES signed document.</param>
        /// <param name="imageWidth">Set image width for visual signature of PAdES signed document.</param>
        /// <param name="imageXAxis">Set image x axis for visual signature of PAdES signed document.</param>
        /// <param name="imageYAxis">Set image y axis for visual signature of PAdES signed document.</param>
        /// <param name="padesVisualSignature">Set visual signature on last page of PAdES signed document. Supported values are TRUE, FALSE. Default value FALSE.</param>
        /// <param name="pageNumber">Set page number for visual signature of PAdES signed document.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: CAdES_BASELINE_B, CAdES_BASELINE_T, CAdES_BASELINE_LT, CAdES_BASELINE_LTA, PAdES_BASELINE_B, PAdES_BASELINE_T, PAdES_BASELINE_LT, PAdES_BASELINE_LTA, XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="signaturePackaging">Signature packaging for calculating data to be signed. Supported packagings are: ENVELOPED, ENVELOPING, DETACHED</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Data to sign retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DigestResponseDto> GetDigestUsingPOSTAsync(string accept_language, FileParameter certificate, FileParameter content, FileParameter data, string digestAlgorithm, int? imageHeight, int? imageWidth, double? imageXAxis, double? imageYAxis, bool? padesVisualSignature, int? pageNumber, string signatureLevel, string signaturePackaging, string xpathLocation, string xpathNamespaces, string xpathPrefixes, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/digest");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (certificate == null)
                        throw new System.ArgumentNullException("certificate");
                    else
                    {
                        var content_certificate_ = new System.Net.Http.StreamContent(certificate.Data);
                        if (!string.IsNullOrEmpty(certificate.ContentType))
                            content_certificate_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(certificate.ContentType);
                        content_.Add(content_certificate_, "certificate", certificate.FileName ?? "certificate");
                    }
                    if (content != null)
                    {
                        var content_content_ = new System.Net.Http.StreamContent(content.Data);
                        if (!string.IsNullOrEmpty(content.ContentType))
                            content_content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(content.ContentType);
                        content_.Add(content_content_, "content", content.FileName ?? "content");
                    }
                    if (data == null)
                        throw new System.ArgumentNullException("data");
                    else
                    {
                        var content_data_ = new System.Net.Http.StreamContent(data.Data);
                        if (!string.IsNullOrEmpty(data.ContentType))
                            content_data_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(data.ContentType);
                        content_.Add(content_data_, "data", data.FileName ?? "data");
                    }
                    if (digestAlgorithm == null)
                        throw new System.ArgumentNullException("digestAlgorithm");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(digestAlgorithm, System.Globalization.CultureInfo.InvariantCulture)), "digestAlgorithm");
                    }
                    if (imageHeight != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(imageHeight, System.Globalization.CultureInfo.InvariantCulture)), "imageHeight");
                    }
                    if (imageWidth != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(imageWidth, System.Globalization.CultureInfo.InvariantCulture)), "imageWidth");
                    }
                    if (imageXAxis != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(imageXAxis, System.Globalization.CultureInfo.InvariantCulture)), "imageXAxis");
                    }
                    if (imageYAxis != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(imageYAxis, System.Globalization.CultureInfo.InvariantCulture)), "imageYAxis");
                    }
                    if (padesVisualSignature != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(padesVisualSignature, System.Globalization.CultureInfo.InvariantCulture)), "padesVisualSignature");
                    }
                    if (pageNumber != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(pageNumber, System.Globalization.CultureInfo.InvariantCulture)), "pageNumber");
                    }
                    if (signatureLevel == null)
                        throw new System.ArgumentNullException("signatureLevel");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(signatureLevel, System.Globalization.CultureInfo.InvariantCulture)), "signatureLevel");
                    }
                    if (signaturePackaging == null)
                        throw new System.ArgumentNullException("signaturePackaging");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(signaturePackaging, System.Globalization.CultureInfo.InvariantCulture)), "signaturePackaging");
                    }
                    if (xpathLocation != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathLocation, System.Globalization.CultureInfo.InvariantCulture)), "xpathLocation");
                    }
                    if (xpathNamespaces != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathNamespaces, System.Globalization.CultureInfo.InvariantCulture)), "xpathNamespaces");
                    }
                    if (xpathPrefixes != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathPrefixes, System.Globalization.CultureInfo.InvariantCulture)), "xpathPrefixes");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DigestResponseDto>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BadRequestErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<BadRequestErrorResponseDto>("Bad request, invalid criteria parameter.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InternalServerErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<InternalServerErrorResponseDto>("Internal server error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DigestResponseDto);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get data to sign of the specified external digest(s) and file name(s)</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512</param>
        /// <param name="externalDigests">Signature external digests for calculating data to be signed.</param>
        /// <param name="fileNames">File names over which external digest is calculated.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Data to sign retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DigestResponseDto> GetDigestExternalUsingPOSTAsync(string accept_language, FileParameter certificate, string digestAlgorithm, System.Collections.Generic.IEnumerable<string> externalDigests, System.Collections.Generic.IEnumerable<string> fileNames, string signatureLevel, string xpathLocation, string xpathNamespaces, string xpathPrefixes)
        {
            return GetDigestExternalUsingPOSTAsync(accept_language, certificate, digestAlgorithm, externalDigests, fileNames, signatureLevel, xpathLocation, xpathNamespaces, xpathPrefixes, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get data to sign of the specified external digest(s) and file name(s)</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512</param>
        /// <param name="externalDigests">Signature external digests for calculating data to be signed.</param>
        /// <param name="fileNames">File names over which external digest is calculated.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Data to sign retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DigestResponseDto> GetDigestExternalUsingPOSTAsync(string accept_language, FileParameter certificate, string digestAlgorithm, System.Collections.Generic.IEnumerable<string> externalDigests, System.Collections.Generic.IEnumerable<string> fileNames, string signatureLevel, string xpathLocation, string xpathNamespaces, string xpathPrefixes, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/digest/external");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (certificate == null)
                        throw new System.ArgumentNullException("certificate");
                    else
                    {
                        var content_certificate_ = new System.Net.Http.StreamContent(certificate.Data);
                        if (!string.IsNullOrEmpty(certificate.ContentType))
                            content_certificate_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(certificate.ContentType);
                        content_.Add(content_certificate_, "certificate", certificate.FileName ?? "certificate");
                    }
                    if (digestAlgorithm == null)
                        throw new System.ArgumentNullException("digestAlgorithm");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(digestAlgorithm, System.Globalization.CultureInfo.InvariantCulture)), "digestAlgorithm");
                    }
                    if (externalDigests == null)
                        throw new System.ArgumentNullException("externalDigests");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(externalDigests, System.Globalization.CultureInfo.InvariantCulture)), "externalDigests");
                    }
                    if (fileNames == null)
                        throw new System.ArgumentNullException("fileNames");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(fileNames, System.Globalization.CultureInfo.InvariantCulture)), "fileNames");
                    }
                    if (signatureLevel == null)
                        throw new System.ArgumentNullException("signatureLevel");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(signatureLevel, System.Globalization.CultureInfo.InvariantCulture)), "signatureLevel");
                    }
                    if (xpathLocation != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathLocation, System.Globalization.CultureInfo.InvariantCulture)), "xpathLocation");
                    }
                    if (xpathNamespaces != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathNamespaces, System.Globalization.CultureInfo.InvariantCulture)), "xpathNamespaces");
                    }
                    if (xpathPrefixes != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathPrefixes, System.Globalization.CultureInfo.InvariantCulture)), "xpathPrefixes");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DigestResponseDto>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BadRequestErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<BadRequestErrorResponseDto>("Bad request, invalid criteria parameter.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InternalServerErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<InternalServerErrorResponseDto>("Internal server error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DigestResponseDto);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create signed document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="content">Content for second and more detached signatures.</param>
        /// <param name="data">Data over which digest should be calculated.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512.</param>
        /// <param name="digestTime">Time of the digest calculation (in response from digest operation).</param>
        /// <param name="imageHeight">Set image height for visual signature of PAdES signed document.</param>
        /// <param name="imageWidth">Set image width for visual signature of PAdES signed document.</param>
        /// <param name="imageXAxis">Set image x axis for visual signature of PAdES signed document.</param>
        /// <param name="imageYAxis">Set image y axis for visual signature of PAdES signed document.</param>
        /// <param name="padesVisualSignature">Set visual signature on last page of PAdES signed document. Supported values are TRUE, FALSE. Default value FALSE.</param>
        /// <param name="pageNumber">Set page number for visual signature of PAdES signed document.</param>
        /// <param name="signature">Digital signature of digest.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: CAdES_BASELINE_B, CAdES_BASELINE_T, CAdES_BASELINE_LT, CAdES_BASELINE_LTA, PAdES_BASELINE_B, PAdES_BASELINE_T, PAdES_BASELINE_LT, PAdES_BASELINE_LTA, XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="signaturePackaging">Signature packaging for calculating data to be signed. Supported packagings are: ENVELOPED, ENVELOPING, DETACHED.</param>
        /// <param name="tsDigestAlgorithm">Signature timestamp digest algorithm for calculating timestamp of data to be signed. Supported algorithms are: SHA256, SHA512.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DocumentResponseDto> CreateSignedDocumentUsingPOSTAsync(string accept_language, FileParameter certificate, FileParameter content, FileParameter data, string digestAlgorithm, long digestTime, int? imageHeight, int? imageWidth, double? imageXAxis, double? imageYAxis, bool? padesVisualSignature, int? pageNumber, FileParameter signature, string signatureLevel, string signaturePackaging, string tsDigestAlgorithm, string xpathLocation, string xpathNamespaces, string xpathPrefixes)
        {
            return CreateSignedDocumentUsingPOSTAsync(accept_language, certificate, content, data, digestAlgorithm, digestTime, imageHeight, imageWidth, imageXAxis, imageYAxis, padesVisualSignature, pageNumber, signature, signatureLevel, signaturePackaging, tsDigestAlgorithm, xpathLocation, xpathNamespaces, xpathPrefixes, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create signed document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="content">Content for second and more detached signatures.</param>
        /// <param name="data">Data over which digest should be calculated.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512.</param>
        /// <param name="digestTime">Time of the digest calculation (in response from digest operation).</param>
        /// <param name="imageHeight">Set image height for visual signature of PAdES signed document.</param>
        /// <param name="imageWidth">Set image width for visual signature of PAdES signed document.</param>
        /// <param name="imageXAxis">Set image x axis for visual signature of PAdES signed document.</param>
        /// <param name="imageYAxis">Set image y axis for visual signature of PAdES signed document.</param>
        /// <param name="padesVisualSignature">Set visual signature on last page of PAdES signed document. Supported values are TRUE, FALSE. Default value FALSE.</param>
        /// <param name="pageNumber">Set page number for visual signature of PAdES signed document.</param>
        /// <param name="signature">Digital signature of digest.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: CAdES_BASELINE_B, CAdES_BASELINE_T, CAdES_BASELINE_LT, CAdES_BASELINE_LTA, PAdES_BASELINE_B, PAdES_BASELINE_T, PAdES_BASELINE_LT, PAdES_BASELINE_LTA, XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="signaturePackaging">Signature packaging for calculating data to be signed. Supported packagings are: ENVELOPED, ENVELOPING, DETACHED.</param>
        /// <param name="tsDigestAlgorithm">Signature timestamp digest algorithm for calculating timestamp of data to be signed. Supported algorithms are: SHA256, SHA512.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DocumentResponseDto> CreateSignedDocumentUsingPOSTAsync(string accept_language, FileParameter certificate, FileParameter content, FileParameter data, string digestAlgorithm, long digestTime, int? imageHeight, int? imageWidth, double? imageXAxis, double? imageYAxis, bool? padesVisualSignature, int? pageNumber, FileParameter signature, string signatureLevel, string signaturePackaging, string tsDigestAlgorithm, string xpathLocation, string xpathNamespaces, string xpathPrefixes, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/document");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (certificate == null)
                        throw new System.ArgumentNullException("certificate");
                    else
                    {
                        var content_certificate_ = new System.Net.Http.StreamContent(certificate.Data);
                        if (!string.IsNullOrEmpty(certificate.ContentType))
                            content_certificate_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(certificate.ContentType);
                        content_.Add(content_certificate_, "certificate", certificate.FileName ?? "certificate");
                    }
                    if (content != null)
                    {
                        var content_content_ = new System.Net.Http.StreamContent(content.Data);
                        if (!string.IsNullOrEmpty(content.ContentType))
                            content_content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(content.ContentType);
                        content_.Add(content_content_, "content", content.FileName ?? "content");
                    }
                    if (data == null)
                        throw new System.ArgumentNullException("data");
                    else
                    {
                        var content_data_ = new System.Net.Http.StreamContent(data.Data);
                        if (!string.IsNullOrEmpty(data.ContentType))
                            content_data_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(data.ContentType);
                        content_.Add(content_data_, "data", data.FileName ?? "data");
                    }
                    if (digestAlgorithm == null)
                        throw new System.ArgumentNullException("digestAlgorithm");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(digestAlgorithm, System.Globalization.CultureInfo.InvariantCulture)), "digestAlgorithm");
                    }
                    if (digestTime == null)
                        throw new System.ArgumentNullException("digestTime");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(digestTime, System.Globalization.CultureInfo.InvariantCulture)), "digestTime");
                    }
                    if (imageHeight != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(imageHeight, System.Globalization.CultureInfo.InvariantCulture)), "imageHeight");
                    }
                    if (imageWidth != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(imageWidth, System.Globalization.CultureInfo.InvariantCulture)), "imageWidth");
                    }
                    if (imageXAxis != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(imageXAxis, System.Globalization.CultureInfo.InvariantCulture)), "imageXAxis");
                    }
                    if (imageYAxis != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(imageYAxis, System.Globalization.CultureInfo.InvariantCulture)), "imageYAxis");
                    }
                    if (padesVisualSignature != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(padesVisualSignature, System.Globalization.CultureInfo.InvariantCulture)), "padesVisualSignature");
                    }
                    if (pageNumber != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(pageNumber, System.Globalization.CultureInfo.InvariantCulture)), "pageNumber");
                    }
                    if (signature == null)
                        throw new System.ArgumentNullException("signature");
                    else
                    {
                        var content_signature_ = new System.Net.Http.StreamContent(signature.Data);
                        if (!string.IsNullOrEmpty(signature.ContentType))
                            content_signature_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(signature.ContentType);
                        content_.Add(content_signature_, "signature", signature.FileName ?? "signature");
                    }
                    if (signatureLevel == null)
                        throw new System.ArgumentNullException("signatureLevel");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(signatureLevel, System.Globalization.CultureInfo.InvariantCulture)), "signatureLevel");
                    }
                    if (signaturePackaging == null)
                        throw new System.ArgumentNullException("signaturePackaging");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(signaturePackaging, System.Globalization.CultureInfo.InvariantCulture)), "signaturePackaging");
                    }
                    if (tsDigestAlgorithm != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(tsDigestAlgorithm, System.Globalization.CultureInfo.InvariantCulture)), "tsDigestAlgorithm");
                    }
                    if (xpathLocation != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathLocation, System.Globalization.CultureInfo.InvariantCulture)), "xpathLocation");
                    }
                    if (xpathNamespaces != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathNamespaces, System.Globalization.CultureInfo.InvariantCulture)), "xpathNamespaces");
                    }
                    if (xpathPrefixes != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathPrefixes, System.Globalization.CultureInfo.InvariantCulture)), "xpathPrefixes");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DocumentResponseDto>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BadRequestErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<BadRequestErrorResponseDto>("Bad request, invalid criteria parameter.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InternalServerErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<InternalServerErrorResponseDto>("Internal server error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DocumentResponseDto);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Extends signed document to upper level</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="content">Content file if document signature is detached.</param>
        /// <param name="signedContent">Signed content (Signature file)</param>
        /// <returns>Extended signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DocumentExtendResponseDto> ExtendSignedDocumentUsingPOSTAsync(string accept_language, FileParameter content, FileParameter signedContent)
        {
            return ExtendSignedDocumentUsingPOSTAsync(accept_language, content, signedContent, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Extends signed document to upper level</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="content">Content file if document signature is detached.</param>
        /// <param name="signedContent">Signed content (Signature file)</param>
        /// <returns>Extended signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DocumentExtendResponseDto> ExtendSignedDocumentUsingPOSTAsync(string accept_language, FileParameter content, FileParameter signedContent, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/document/extend");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (content != null)
                    {
                        var content_content_ = new System.Net.Http.StreamContent(content.Data);
                        if (!string.IsNullOrEmpty(content.ContentType))
                            content_content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(content.ContentType);
                        content_.Add(content_content_, "content", content.FileName ?? "content");
                    }
                    if (signedContent == null)
                        throw new System.ArgumentNullException("signedContent");
                    else
                    {
                        var content_signedContent_ = new System.Net.Http.StreamContent(signedContent.Data);
                        if (!string.IsNullOrEmpty(signedContent.ContentType))
                            content_signedContent_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(signedContent.ContentType);
                        content_.Add(content_signedContent_, "signedContent", signedContent.FileName ?? "signedContent");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DocumentExtendResponseDto>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BadRequestErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<BadRequestErrorResponseDto>("Bad request, invalid criteria parameter.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InternalServerErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<InternalServerErrorResponseDto>("Internal server error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DocumentExtendResponseDto);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create signed document with externally entered digests</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512.</param>
        /// <param name="digestTime">Time of the digest calculation (in response from digest operation).</param>
        /// <param name="externalDigests">Signature external digests for calculating data to be signed.</param>
        /// <param name="fileNames">File names over which external digest is calculated.</param>
        /// <param name="signature">Digital signature of digest.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="tsDigestAlgorithm">Signature timestamp digest method for calculating timestamp of data to be signed. Supported algorithms are SHA256, SHA512.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DocumentResponseDto> CreateSignedDocumentExternalDigestUsingPOSTAsync(string accept_language, FileParameter certificate, string digestAlgorithm, long digestTime, System.Collections.Generic.IEnumerable<string> externalDigests, System.Collections.Generic.IEnumerable<string> fileNames, FileParameter signature, string signatureLevel, string tsDigestAlgorithm, string xpathLocation, string xpathNamespaces, string xpathPrefixes)
        {
            return CreateSignedDocumentExternalDigestUsingPOSTAsync(accept_language, certificate, digestAlgorithm, digestTime, externalDigests, fileNames, signature, signatureLevel, tsDigestAlgorithm, xpathLocation, xpathNamespaces, xpathPrefixes, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create signed document with externally entered digests</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificate">X509 Certificate used for signature.</param>
        /// <param name="digestAlgorithm">Signature digest algorithm for calculating data to be signed. Supported algorithms are: SHA256, SHA384, SHA512.</param>
        /// <param name="digestTime">Time of the digest calculation (in response from digest operation).</param>
        /// <param name="externalDigests">Signature external digests for calculating data to be signed.</param>
        /// <param name="fileNames">File names over which external digest is calculated.</param>
        /// <param name="signature">Digital signature of digest.</param>
        /// <param name="signatureLevel">Signature level for calculating data to be signed. Supported levels are: XAdES_BASELINE_B, XAdES_BASELINE_T, XAdES_BASELINE_LT, XAdES_BASELINE_LTA.</param>
        /// <param name="tsDigestAlgorithm">Signature timestamp digest method for calculating timestamp of data to be signed. Supported algorithms are SHA256, SHA512.</param>
        /// <param name="xpathLocation">Area where the signature will be added (XAdES Enveloped).</param>
        /// <param name="xpathNamespaces">XPath signature namespaces (XAdES Enveloped) delimited with comma.</param>
        /// <param name="xpathPrefixes">XPath signature prefixes (XAdES Enveloped) delimited with comma.</param>
        /// <returns>Signed document data was retrieved successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DocumentResponseDto> CreateSignedDocumentExternalDigestUsingPOSTAsync(string accept_language, FileParameter certificate, string digestAlgorithm, long digestTime, System.Collections.Generic.IEnumerable<string> externalDigests, System.Collections.Generic.IEnumerable<string> fileNames, FileParameter signature, string signatureLevel, string tsDigestAlgorithm, string xpathLocation, string xpathNamespaces, string xpathPrefixes, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/document/external");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (certificate == null)
                        throw new System.ArgumentNullException("certificate");
                    else
                    {
                        var content_certificate_ = new System.Net.Http.StreamContent(certificate.Data);
                        if (!string.IsNullOrEmpty(certificate.ContentType))
                            content_certificate_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(certificate.ContentType);
                        content_.Add(content_certificate_, "certificate", certificate.FileName ?? "certificate");
                    }
                    if (digestAlgorithm == null)
                        throw new System.ArgumentNullException("digestAlgorithm");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(digestAlgorithm, System.Globalization.CultureInfo.InvariantCulture)), "digestAlgorithm");
                    }
                    if (digestTime == null)
                        throw new System.ArgumentNullException("digestTime");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(digestTime, System.Globalization.CultureInfo.InvariantCulture)), "digestTime");
                    }
                    if (externalDigests == null)
                        throw new System.ArgumentNullException("externalDigests");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(externalDigests, System.Globalization.CultureInfo.InvariantCulture)), "externalDigests");
                    }
                    if (fileNames == null)
                        throw new System.ArgumentNullException("fileNames");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(fileNames, System.Globalization.CultureInfo.InvariantCulture)), "fileNames");
                    }
                    if (signature == null)
                        throw new System.ArgumentNullException("signature");
                    else
                    {
                        var content_signature_ = new System.Net.Http.StreamContent(signature.Data);
                        if (!string.IsNullOrEmpty(signature.ContentType))
                            content_signature_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(signature.ContentType);
                        content_.Add(content_signature_, "signature", signature.FileName ?? "signature");
                    }
                    if (signatureLevel == null)
                        throw new System.ArgumentNullException("signatureLevel");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(signatureLevel, System.Globalization.CultureInfo.InvariantCulture)), "signatureLevel");
                    }
                    if (tsDigestAlgorithm != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(tsDigestAlgorithm, System.Globalization.CultureInfo.InvariantCulture)), "tsDigestAlgorithm");
                    }
                    if (xpathLocation != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathLocation, System.Globalization.CultureInfo.InvariantCulture)), "xpathLocation");
                    }
                    if (xpathNamespaces != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathNamespaces, System.Globalization.CultureInfo.InvariantCulture)), "xpathNamespaces");
                    }
                    if (xpathPrefixes != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(xpathPrefixes, System.Globalization.CultureInfo.InvariantCulture)), "xpathPrefixes");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DocumentResponseDto>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BadRequestErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<BadRequestErrorResponseDto>("Bad request, invalid criteria parameter.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InternalServerErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<InternalServerErrorResponseDto>("Internal server error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(DocumentResponseDto);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Validate signed document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="attachValidationCertificatesToResult">Add base64 encoded certificates to result. Supported values are: TRUE, FALSE. Default value FALSE.</param>
        /// <param name="attachValidationReportsToResult">Add base64 encoded reports to result. Supported values are: TRUE, FALSE. Default value FALSE.</param>
        /// <param name="content">Content file if document signature is detached.</param>
        /// <param name="signedContent">Signed content (Signature file)</param>
        /// <param name="validationLevel">Validation level to be used for validation. If none is specified - it is determined by the document structure. Supported validation levels are: BASIC_SIGNATURES, TIMESTAMPS, LONG_TERM_DATA, ARCHIVAL_DATA.</param>
        /// <returns>Validated signed document reports produced successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ValidateDocumentResponseDto> ValidateSignedDocumentUsingPOSTAsync(string accept_language, bool? attachValidationCertificatesToResult, bool? attachValidationReportsToResult, FileParameter content, FileParameter signedContent, string validationLevel)
        {
            return ValidateSignedDocumentUsingPOSTAsync(accept_language, attachValidationCertificatesToResult, attachValidationReportsToResult, content, signedContent, validationLevel, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Validate signed document</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="attachValidationCertificatesToResult">Add base64 encoded certificates to result. Supported values are: TRUE, FALSE. Default value FALSE.</param>
        /// <param name="attachValidationReportsToResult">Add base64 encoded reports to result. Supported values are: TRUE, FALSE. Default value FALSE.</param>
        /// <param name="content">Content file if document signature is detached.</param>
        /// <param name="signedContent">Signed content (Signature file)</param>
        /// <param name="validationLevel">Validation level to be used for validation. If none is specified - it is determined by the document structure. Supported validation levels are: BASIC_SIGNATURES, TIMESTAMPS, LONG_TERM_DATA, ARCHIVAL_DATA.</param>
        /// <returns>Validated signed document reports produced successfully</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ValidateDocumentResponseDto> ValidateSignedDocumentUsingPOSTAsync(string accept_language, bool? attachValidationCertificatesToResult, bool? attachValidationReportsToResult, FileParameter content, FileParameter signedContent, string validationLevel, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/document/validate");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (attachValidationCertificatesToResult != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(attachValidationCertificatesToResult, System.Globalization.CultureInfo.InvariantCulture)), "attachValidationCertificatesToResult");
                    }
                    if (attachValidationReportsToResult != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(attachValidationReportsToResult, System.Globalization.CultureInfo.InvariantCulture)), "attachValidationReportsToResult");
                    }
                    if (content != null)
                    {
                        var content_content_ = new System.Net.Http.StreamContent(content.Data);
                        if (!string.IsNullOrEmpty(content.ContentType))
                            content_content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(content.ContentType);
                        content_.Add(content_content_, "content", content.FileName ?? "content");
                    }
                    if (signedContent == null)
                        throw new System.ArgumentNullException("signedContent");
                    else
                    {
                        var content_signedContent_ = new System.Net.Http.StreamContent(signedContent.Data);
                        if (!string.IsNullOrEmpty(signedContent.ContentType))
                            content_signedContent_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(signedContent.ContentType);
                        content_.Add(content_signedContent_, "signedContent", signedContent.FileName ?? "signedContent");
                    }
                    if (validationLevel != null)
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(validationLevel, System.Globalization.CultureInfo.InvariantCulture)), "validationLevel");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ValidateDocumentResponseDto>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BadRequestErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<BadRequestErrorResponseDto>("Bad request, invalid criteria parameter.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InternalServerErrorResponseDto>(response_, headers_).ConfigureAwait(false);
                            throw new SwaggerException<InternalServerErrorResponseDto>("Internal server error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ValidateDocumentResponseDto);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }
    
            public T Object { get; }
    
            public string Text { get; }
        }
    
        public bool ReadResponseAsString { get; set; }
        
        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }
        
            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new SwaggerException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new SwaggerException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BadRequestErrorResponseDto 
    {
        /// <summary>Internal code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Error response message</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static BadRequestErrorResponseDto FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<BadRequestErrorResponseDto>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DigestResponseDto 
    {
        /// <summary>Internal code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Digest value time</summary>
        [Newtonsoft.Json.JsonProperty("digestTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DigestTime { get; set; }
    
        /// <summary>Digest value</summary>
        [Newtonsoft.Json.JsonProperty("digestValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] DigestValue { get; set; }
    
        /// <summary>Response message</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static DigestResponseDto FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DigestResponseDto>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DocumentExtendResponseDto 
    {
        /// <summary>Internal code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Extended signed document value</summary>
        [Newtonsoft.Json.JsonProperty("extendedData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] ExtendedData { get; set; }
    
        /// <summary>Signed document content type</summary>
        [Newtonsoft.Json.JsonProperty("extendedDataContentType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExtendedDataContentType { get; set; }
    
        /// <summary>Signed document file name</summary>
        [Newtonsoft.Json.JsonProperty("extendedDataFileName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExtendedDataFileName { get; set; }
    
        /// <summary>Response message</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        /// <summary>Signature form value</summary>
        [Newtonsoft.Json.JsonProperty("signatureForm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DocumentExtendResponseDtoSignatureForm? SignatureForm { get; set; }
    
        /// <summary>Signature level value</summary>
        [Newtonsoft.Json.JsonProperty("signatureLevel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DocumentExtendResponseDtoSignatureLevel? SignatureLevel { get; set; }
    
        /// <summary>Timestamp not after value</summary>
        [Newtonsoft.Json.JsonProperty("timestampNotAfter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TimestampNotAfter { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static DocumentExtendResponseDto FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DocumentExtendResponseDto>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DocumentResponseDto 
    {
        /// <summary>Internal code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Signed document content type</summary>
        [Newtonsoft.Json.JsonProperty("contentType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContentType { get; set; }
    
        /// <summary>Signed document file name</summary>
        [Newtonsoft.Json.JsonProperty("fileName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FileName { get; set; }
    
        /// <summary>Response message</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        /// <summary>Signed document value</summary>
        [Newtonsoft.Json.JsonProperty("signedData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] SignedData { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static DocumentResponseDto FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DocumentResponseDto>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InternalServerErrorResponseDto 
    {
        /// <summary>Internal code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Error response message</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static InternalServerErrorResponseDto FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<InternalServerErrorResponseDto>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RevocationTokenDto 
    {
        /// <summary>Signer certificate revocation reason</summary>
        [Newtonsoft.Json.JsonProperty("revocationReason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RevocationReason { get; set; }
    
        /// <summary>Revocation time in miliseconds from 1970</summary>
        [Newtonsoft.Json.JsonProperty("revocationTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? RevocationTime { get; set; }
    
        /// <summary>Revocation token production time in miliseconds from 1970</summary>
        [Newtonsoft.Json.JsonProperty("revocationTokenProductionTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? RevocationTokenProductionTime { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static RevocationTokenDto FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<RevocationTokenDto>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignatureDto 
    {
        /// <summary>Signature Id</summary>
        [Newtonsoft.Json.JsonProperty("signatureId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignatureId { get; set; }
    
        /// <summary>Signature valid</summary>
        [Newtonsoft.Json.JsonProperty("signatureValid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignatureValid { get; set; }
    
        /// <summary>Digest algorithm</summary>
        [Newtonsoft.Json.JsonProperty("digestAlgorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DigestAlgorithm { get; set; }
    
        /// <summary>Signature algorithm</summary>
        [Newtonsoft.Json.JsonProperty("signatureAlgorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignatureAlgorithm { get; set; }
    
        /// <summary>Signature file content type</summary>
        [Newtonsoft.Json.JsonProperty("signatureFileContentType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignatureFileContentType { get; set; }
    
        /// <summary>Signature form</summary>
        [Newtonsoft.Json.JsonProperty("signatureForm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignatureForm { get; set; }
    
        /// <summary>Signature level</summary>
        [Newtonsoft.Json.JsonProperty("signatureLevel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignatureLevel { get; set; }
    
        /// <summary>Signature time in miliseconds from 1970</summary>
        [Newtonsoft.Json.JsonProperty("signatureTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SignatureTime { get; set; }
    
        /// <summary>Signed by</summary>
        [Newtonsoft.Json.JsonProperty("signedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignedBy { get; set; }
    
        /// <summary>Signer certificate ID</summary>
        [Newtonsoft.Json.JsonProperty("signerCertificateID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignerCertificateID { get; set; }
    
        /// <summary>Signer Certificate DN</summary>
        [Newtonsoft.Json.JsonProperty("signerCertificateDN", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignerCertificateDN { get; set; }
    
        /// <summary>Signer certificate</summary>
        [Newtonsoft.Json.JsonProperty("signerBase64EncodedCertificate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignerBase64EncodedCertificate { get; set; }
    
        /// <summary>Signer personal identifier</summary>
        [Newtonsoft.Json.JsonProperty("signerPersonalIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignerPersonalIdentifier { get; set; }
    
        /// <summary>Signer organization identifier</summary>
        [Newtonsoft.Json.JsonProperty("signerOrganizationIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignerOrganizationIdentifier { get; set; }
    
        /// <summary>Signer certificate serial number identifier</summary>
        [Newtonsoft.Json.JsonProperty("signerCertificateSerialNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignerCertificateSerialNumber { get; set; }
    
        /// <summary>Signer certificate signature is valid</summary>
        [Newtonsoft.Json.JsonProperty("signerCertificateSignatureIsValid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignerCertificateSignatureIsValid { get; set; }
    
        /// <summary>Signer certificate is trusted</summary>
        [Newtonsoft.Json.JsonProperty("signerCertificateIsTrusted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignerCertificateIsTrusted { get; set; }
    
        /// <summary>Signer certificate signature algorithm</summary>
        [Newtonsoft.Json.JsonProperty("signerCertificateSignatureAlgorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignerCertificateSignatureAlgorithm { get; set; }
    
        /// <summary>Issuer certificate DN</summary>
        [Newtonsoft.Json.JsonProperty("issuerCertificateDN", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IssuerCertificateDN { get; set; }
    
        /// <summary>Issuer certificate</summary>
        [Newtonsoft.Json.JsonProperty("issuerBase64EncodedCertificate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IssuerBase64EncodedCertificate { get; set; }
    
        /// <summary>Timestamp detailed data</summary>
        [Newtonsoft.Json.JsonProperty("timestampsDtos", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TimestampTokenDto> TimestampsDtos { get; set; }
    
        /// <summary>Revocation detailed data</summary>
        [Newtonsoft.Json.JsonProperty("revocationTokenDtos", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RevocationTokenDto> RevocationTokenDtos { get; set; }
    
        /// <summary>Signature info list</summary>
        [Newtonsoft.Json.JsonProperty("signatureInfosList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> SignatureInfosList { get; set; }
    
        /// <summary>Signature warning list</summary>
        [Newtonsoft.Json.JsonProperty("signatureWarningsList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> SignatureWarningsList { get; set; }
    
        /// <summary>Signature error list</summary>
        [Newtonsoft.Json.JsonProperty("signatureErrorsList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> SignatureErrorsList { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SignatureDto FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignatureDto>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TimestampTokenDto 
    {
        /// <summary>Timestamp token id</summary>
        [Newtonsoft.Json.JsonProperty("timestampTokenID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TimestampTokenID { get; set; }
    
        /// <summary>Timestamp token time in miliseconds from 1970</summary>
        [Newtonsoft.Json.JsonProperty("timestampGenerationTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TimestampGenerationTime { get; set; }
    
        /// <summary>Timestamp type</summary>
        [Newtonsoft.Json.JsonProperty("timestampType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TimestampType { get; set; }
    
        /// <summary>Timestamp certificate tokens ids</summary>
        [Newtonsoft.Json.JsonProperty("timestampCertificateTokensIDs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> TimestampCertificateTokensIDs { get; set; }
    
        /// <summary>Timestamp certificate token trusted list</summary>
        [Newtonsoft.Json.JsonProperty("timestampCertificateTokensTrusted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> TimestampCertificateTokensTrusted { get; set; }
    
        /// <summary>Timestamp issuers list</summary>
        [Newtonsoft.Json.JsonProperty("timestampCertificateDNs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> TimestampCertificateDNs { get; set; }
    
        /// <summary>Timestamp certificates</summary>
        [Newtonsoft.Json.JsonProperty("timestampBase64EncodedCertificates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> TimestampBase64EncodedCertificates { get; set; }
    
        /// <summary>Timestamp digest algorithms</summary>
        [Newtonsoft.Json.JsonProperty("timestampDigestAlgorithms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> TimestampDigestAlgorithms { get; set; }
    
        /// <summary>Timestamp signature algorithms</summary>
        [Newtonsoft.Json.JsonProperty("timestampSignatureAlgorithms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> TimestampSignatureAlgorithms { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TimestampTokenDto FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TimestampTokenDto>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ValidateDocumentResponseDto 
    {
        /// <summary>Internal code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Response message</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        /// <summary>Validated signed document status</summary>
        [Newtonsoft.Json.JsonProperty("documentStatusValid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DocumentStatusValid { get; set; }
    
        /// <summary>Signature file name</summary>
        [Newtonsoft.Json.JsonProperty("signatureFileName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignatureFileName { get; set; }
    
        /// <summary>Number of signatures over the validating document</summary>
        [Newtonsoft.Json.JsonProperty("signaturesCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SignaturesCount { get; set; }
    
        /// <summary>Number of valid signatures over the validating document</summary>
        [Newtonsoft.Json.JsonProperty("validSignaturesCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ValidSignaturesCount { get; set; }
    
        /// <summary>Validation time in miliseconds from 1970</summary>
        [Newtonsoft.Json.JsonProperty("validationDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ValidationDateTime { get; set; }
    
        /// <summary>Base 64 encoded simple report XML</summary>
        [Newtonsoft.Json.JsonProperty("base64EncodedSimpleReportXML", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Base64EncodedSimpleReportXML { get; set; }
    
        /// <summary>Base 64 encoded detailed report XML</summary>
        [Newtonsoft.Json.JsonProperty("base64EncodedDetailedReportXML", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Base64EncodedDetailedReportXML { get; set; }
    
        /// <summary>Base 64 encoded ETSI validation report XML</summary>
        [Newtonsoft.Json.JsonProperty("base64EncodedETSIValidationReportXML", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Base64EncodedETSIValidationReportXML { get; set; }
    
        /// <summary>Single signature data</summary>
        [Newtonsoft.Json.JsonProperty("signatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SignatureDto> Signatures { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ValidateDocumentResponseDto FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ValidateDocumentResponseDto>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DocumentExtendResponseDtoSignatureForm
    {
        [System.Runtime.Serialization.EnumMember(Value = @"XAdES")]
        XAdES = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CAdES")]
        CAdES = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAdES")]
        PAdES = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PKCS7")]
        PKCS7 = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DocumentExtendResponseDtoSignatureLevel
    {
        [System.Runtime.Serialization.EnumMember(Value = @"XML-NOT-ETSI")]
        XMLNOTETSI = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XAdES-C")]
        XAdESC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XAdES-X")]
        XAdESX = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XAdES-XL")]
        XAdESXL = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XAdES-A")]
        XAdESA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XAdES-BASELINE-LTA")]
        XAdESBASELINELTA = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XAdES-BASELINE-LT")]
        XAdESBASELINELT = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XAdES-BASELINE-T")]
        XAdESBASELINET = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XAdES-BASELINE-B")]
        XAdESBASELINEB = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CMS-NOT-ETSI")]
        CMSNOTETSI = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CAdES-BASELINE-LTA")]
        CAdESBASELINELTA = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CAdES-BASELINE-LT")]
        CAdESBASELINELT = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CAdES-BASELINE-T")]
        CAdESBASELINET = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CAdES-BASELINE-B")]
        CAdESBASELINEB = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CAdES-101733-C")]
        CAdES101733C = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CAdES-101733-X")]
        CAdES101733X = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CAdES-101733-A")]
        CAdES101733A = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PDF-NOT-ETSI")]
        PDFNOTETSI = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAdES-BASELINE-LTA")]
        PAdESBASELINELTA = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAdES-BASELINE-LT")]
        PAdESBASELINELT = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAdES-BASELINE-T")]
        PAdESBASELINET = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAdES-BASELINE-B")]
        PAdESBASELINEB = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PKCS7-B")]
        PKCS7B = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PKCS7-T")]
        PKCS7T = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PKCS7-LT")]
        PKCS7LT = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PKCS7-LTA")]
        PKCS7LTA = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 26,
    
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(System.IO.Stream data)
            : this (data, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName)
            : this (data, fileName, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName, string contentType)
        {
            Data = data;
            FileName = fileName;
            ContentType = contentType;
        }

        public System.IO.Stream Data { get; private set; }

        public string FileName { get; private set; }

        public string ContentType { get; private set; }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class SwaggerException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public SwaggerException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class SwaggerException<TResult> : SwaggerException
    {
        public TResult Result { get; private set; }

        public SwaggerException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108